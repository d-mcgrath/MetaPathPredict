sum(-lgamma(alpha + beta) - lgamma(alpha + y_l)
- lgamma(beta + (n * m_l) - y_l) + lgamma(alpha)
+ lgamma(beta) + lgamma(alpha + beta + (n * m_l)))
}
## m_l = length of collection C_l
## m_j = length of collection C_j
## C_j = collection of known genomes to which fragments f_j belong
## n = length of module (# genes)
## alpha + beta MLEs
## k_j = OBSERVED VALUE OF K_j, which is the NUMBER of MP genes in a genome g_j, of which f_j is a fragment
get_pj.k_betabinomial <- function(alpha, beta, y_j, n, m_j, x_j) { # k = seq_along(x_j:(n - 1)) # x_j should never equal n; if it does, the module step is complete/present
k <- x_j:(n - 1)
A_j <- alpha + y_j
B_j <- beta + (n * m_j) - y_j
pj.k <- exp(lgamma(A_j + B_j) + lgamma(A_j + k) + lgamma(B_j + n - k) - lgamma(A_j) - lgamma(B_j) - lgamma(A_j + B_j + n))
return(pj.k)
}
get_pj.n_betabinomial <- function(alpha, beta, y_j, n, m_j, x_j) {
k <- n
A_j <- alpha + y_j
B_j <- beta + (n * m_j) - y_j
pj.n <- exp(lgamma(A_j + B_j) + lgamma(A_j + k) + lgamma(B_j + n - k) - lgamma(A_j) - lgamma(B_j) - lgamma(A_j + B_j + n))
return(pj.n)
}
calculate_posterior <- function(p.xj_n, p.xj_nbar, alpha, beta, y_j, n, m_j, x_j) {
pj.n <- get_pj.n_betabinomial(alpha, beta, y_j, n, m_j, x_j)
p.n_xj <- (p.xj_n * pj.n) / ((p.xj_n * pj.n) + (p.xj_nbar * (1 - pj.n)))
return(p.n_xj)
}
# Calculate the posterior probability that a module step is present,
# given the genome completeness estimate p
get_posteriors <- function(modules_list) {
posterior_results <- list()
posterior_results <- purrr::map(seq_along(modules_list), ~ {
posterior_results[[.x]] <- modules_list[[.x]] %>%
dplyr::rowwise() %>%
dplyr::mutate(pj.k = list(get_pj.k_betabinomial(alpha, beta, y_j, n, m_j, x_j)),
p.xj_nbar = get_p.xj_nbar(n, x_j, p_j, pj.k),
p.xj_n = list(get_p.xj_n(n, x_j, p_j)), # VERIFY THAT pj.k IS EQUIVALENT TO "p_j" ## UPDATE: THEY ARE NOT EQUIVALENT.
probability = calculate_posterior(p.xj_n, p.xj_nbar, alpha, beta, y_j, n, m_j, x_j)) %>%
dplyr::select(-c(n, x_j, p_j, y_j, m_j, alpha, beta, pj.k, p.xj_nbar, p.xj_n))
})
return(posterior_results)
}
#' @importFrom magrittr "%>%"
get.knumber_vectors <- function(userData, posterior_data) { #posterior_data is a list - with posterior probabilities calculated
input_data <- userData %>%
dplyr::ungroup() %>%
{if ('genome_name' %in% colnames(userData))
dplyr::select(., k_number, genome_name) %>%
tibble::column_to_rownames(var = 'genome_name')
else dplyr::select(., k_number, taxonomy) %>%
tibble::column_to_rownames(var = 'taxonomy')} %>%
t() %>%
dplyr::as_tibble(~ vctrs::vec_as_names(repair = "unique", quiet = TRUE))
knumber_data <- patt.kegg_modules %>%
dplyr::bind_cols(input_data) %>%
dplyr::group_by(step, k_numbers) %>%
dplyr::summarize(dplyr::across(!1:3, ~ stringr::str_extract(
string = .x, pattern = k_numbers)), .groups = 'drop') %>%
dplyr::select(-c(k_numbers, step))
x_j.tibble_list <- list()
x_j.tibble_list <- purrr::map(1:length(knumber_data), ~ {
x_j.tibble_list[[.x]] <- knumber_data[.x] %>%
dplyr::rename(k_number = 1) %>%
dplyr::mutate(step = patt.kegg_modules$step,
k_rule = patt.kegg_modules$k_numbers) %>%
dplyr::left_join(dplyr::select(posterior_data[[.x]], step, `Module step present`, probability), by = 'step') %>%
dplyr::mutate(probability = dplyr::case_when(`Module step present` == TRUE & is.na(probability) ~ -1,
TRUE ~ probability),
k_number = dplyr::case_when(is.na(k_number) ~ k_rule,
TRUE ~ k_number)) %>%
tidyr::separate_rows(k_number, sep = '\\|')
x_j.tibble_list[[.x]] <- purrr::as_vector(x_j.tibble_list[[.x]]$probability) %>%
purrr::set_names(x_j.tibble_list[[.x]]$k_number)
}) %>%
purrr::set_names(nm = names(knumber_data))
return(x_j.tibble_list)
}
#' @export
create_kegg_maps <- function(k_vector.list, pathway_id, output_dir = '.',
k_numbers = TRUE, ec_numbers = FALSE,
present_gene_color = 'plum2', probability_gene_color = 'seagreen2') {
pathview_output <- list()
if (k_numbers == TRUE & ec_numbers == FALSE) {
purrr::imap(k_vector.list, ~ {
purrr::map(pathway_id, function(.p_id) {
pathview_output[[.y]] <- pathview::pathview(gene.data = .x, pathway.id = .p_id,
species = 'ko', out.suffix = names(k_vector.list[.y]),
kegg.dir = output_dir, low = list(gene = present_gene_color, cpd = 'blue'),
high = list(gene = probability_gene_color, cpd = 'yellow'),
bins = list(genes = 14, cpd = 14), map.symbol = TRUE, same.layer = FALSE)
})
})
} else if (k_numbers == FALSE & ec_numbers == TRUE) {
purrr::imap(k_vector.list, ~ {
purrr::map(pathway_id, function(.p_id) {
pathview_output[[.y]] <- pathview::pathview(gene.data = .x, pathway.id = .p_id,
species = 'ko', out.suffix = names(k_vector.list[.y]),
kegg.dir = output_dir, low = list(gene = present_gene_color, cpd = 'blue'),
high = list(gene = probability_gene_color, cpd = 'yellow'),
bins = list(genes = 14, cpd = 14))
})
})
} else {cli::cli_alert_danger("Argument 'k_numbers' or 'ec_numbers' must be TRUE. Both cannot be TRUE, and both cannot be FALSE. Please make sure only one of them is TRUE.")
stop()}
}
#' This function is used to reconstruct metabolic pathways based on present KEGG Orthology terms. For any
#' incomplete pathways with missing reactions, it will then calculate the probability that each missing reaction
#' is present in the input genome but was missed in the sampling process. It takes in user input in the form of
#' an object created with a read_data function call.
#' @param userData Created with the read_data function - KEGG Orthology data for one or more bacteria/archaea
#' @param output_dir The full or relative path to an output directory where result and summary output will be saved as TSV flatfiles
#' @param moduleVector An optional vector of specific KEGG Modules to scan user annotations and calculate probabilities for
#' @importFrom magrittr "%>%"
#' @export
MetaPredict <- function(userData, output_dir = NULL, moduleVector = NULL, strict = FALSE) {
cli::cli_h1('Starting MetaPredict')
cli::cli_alert_info('Formatting input data...')
if (missing(userData)) {
cli::cli_alert_danger('Input userData not detected in global environment. Make sure you have run read_genome_data() or read_metagenome_data() on your data and have listed your input data object for the userData argument.')
stop()
}
cli::cli_alert_info('Reconstructing metabolic pathways and performing prediction calculations...')
x_j.list <- get.x_j(userData)
results <- map_modules_to(x_j.list, userData, strict = strict)# this function should be split into 2 parts
results <- get_parameters(results, moduleVector = moduleVector)
results <- get_posteriors(results)
if (unique(userData$data_type) == 'metagenome') {
results <- results %>%
dplyr::bind_rows() %>%
dplyr::arrange(module_class, step) %>%
dplyr::mutate(metagenome_name = unique(userData$metagenome_name))
summary_information <- summarize_metagenome_output(results)
#heatmaps <- create_heatmaps_from(results, userData, metagenome = TRUE)
output <- list(list(summary_information, results)) %>% #, heatmaps)) %>%
purrr::set_names(unique(userData$metagenome_name))
if (is.null(output_dir)) {
cli::cli_alert_success('Finished KEGG metabolic pathway reconstruction and KEGG Module probability calculations. Output is in a list.')
cli::cli_alert_info('Enter View(results[[(x)]][[1]]) to look at summary information, View(results[[(x)]][[2]] for the full results.') #, and print(results[[(x)]][[3]]) for pathway completion heatmaps.')
cli::cli_alert_warning('Make sure to change (x) to a number between 1 and x, with x equal to the total amount of input genome annotations.')
cli::cli_alert_info("To save results, run the following command: save_results(output_dir = '/path/to/output/directory'). Note: the output directory will be created if it does not exist.")
cli::cli_h1('All done.')
return(output)
}
} else {
summary_information <- summarize_genome_output(results)
#heatmaps <- purrr::map(results, ~ {create_heatmaps_from(.x, userData)})
output <- purrr::transpose(list(summary_information, results)) #, heatmaps))
if (is.null(output_dir)) {
cli::cli_alert_success('Finished KEGG metabolic pathway reconstruction and reaction probability calculations. Output is in a list.')
cli::cli_alert_info('Enter View(results[[(x)]][[1]]) to look at summary information, View(results[[(x)]][[2]] for the full results.') #, and print(results[[(x)]][[3]]) for pathway completion heatmaps.')
cli::cli_alert_warning('Make sure to change (x) to a number from 1 to x, with x equal to the total amount of input genome/metagenome inputs')
cli::cli_alert_info("To save results, run the following command: save_results(output_dir = '/path/to/output/directory/'). Note: the output directory will be created if it does not exist.")
cli::cli_h1('All done.')
return(output)
}
}
if (!is.null(output_dir)) {
save_results(output, output_dir)
cli::cli_alert_success('Finished KEGG metabolic pathway reconstruction and reaction probability calculations. Output is in directory: {output_dir}')
cli::cli_h1('All done.')
return(output)
}
}
## ADD GENOME/METAGENOME NAME AS A COLUMN
summarize_genome_output <- function(.data) {
.data <- purrr::map(seq_along(.data), ~ {
.data[[.x]] <- .data[[.x]] %>%
dplyr::filter(!(duplicated(step))) %>%
dplyr::group_by(module) %>%
dplyr::add_tally(`Module step present` == TRUE, name = 'steps_present') %>%
dplyr::add_tally(length(module), name = 'module_length') %>%
dplyr::add_tally(`Module step present` == FALSE, name = 'predicted') %>%
dplyr::add_tally(probability >= 0.75, name = 'p_greater_75') %>%
dplyr::select(taxonomy, lowest, module_name, module_class, module, steps_present, module_length,
predicted, p_greater_75) %>%
dplyr::distinct() %>%
dplyr::mutate('Module steps present' = paste(steps_present, module_length, sep = '/'),
'Module steps predicted' = paste(predicted, module_length, sep = '/'),
'Predictions (P > 0.75)' = paste(p_greater_75, module_length, sep = '/'),
'Predicted completeness (P > 0.75)' = paste(steps_present+p_greater_75, module_length, sep = '/')) %>%
dplyr::rename('Module name' = module_name, 'Module class' = module_class, 'Module' = module, 'Taxonomy' = taxonomy) %>%
dplyr::select(-c(steps_present, module_length, p_greater_75, predicted))
})
return(.data)
}
summarize_metagenome_output <- function(.data) {
.data %>%
dplyr::filter(!(duplicated(step))) %>%
dplyr::group_by(module, lowest) %>%
dplyr::add_tally(`Module step present` == TRUE, name = 'steps_present') %>%
dplyr::add_tally(length(module), name = 'module_length') %>%
dplyr::add_tally(`Module step present` == FALSE, name = 'predicted') %>%
dplyr::add_tally(probability >= 0.75, name = 'p_greater_75') %>%
dplyr::select(taxonomy, lowest, module_name, module_class, module, steps_present, module_length,
predicted, p_greater_75) %>%
dplyr::distinct() %>%
dplyr::mutate('Module steps present' = paste(steps_present, module_length, sep = '/'),
'Module steps predicted' = paste(predicted, module_length, sep = '/'),
'Predictions (P > 0.75)' = paste(p_greater_75, module_length, sep = '/'),
'Predicted completeness (P > 0.75)' = paste(steps_present + p_greater_75, module_length, sep = '/')) %>%
dplyr::rename('Module name' = module_name, 'Module class' = module_class, 'Module' = module, 'Taxonomy' = taxonomy) %>%
dplyr::select(-c(steps_present, module_length, p_greater_75, predicted))
}
#' @export
save_results <- function(output, output_dir) {
if (!dir.exists(output_dir)) {
cli::cli_alert_warning('Creating output directory {output_dir}')
dir.create(output_dir)
}
if (!stringr::str_detect(output_dir, '.*/$')) {
output_dir <- sub('(.*)', '\\1\\/', output_dir, perl = TRUE)
}
purrr::map(1:length(output), ~ {
readr::write_tsv(output[[.x]][[1]], file = paste0(output_dir, names(output)[.x], '_summary-information.tsv'))
readr::write_tsv(output[[.x]][[2]], file = paste0(output_dir, names(output)[.x], '_results.tsv'))
#png(filename = paste0(output_dir, names(output)[.x], '-heatmaps.png'), units = 'in', width = 30, height = 10, res = 500)
#print(output[[.x]][[3]])
#dev.off()
})
}
#' @importFrom magrittr "%>%"
get.x_j <- function(userData) {
input_data <- userData %>%
dplyr::ungroup() %>%
{if ('genome_name' %in% colnames(userData))
dplyr::select(., k_number, genome_name) %>%
tibble::column_to_rownames(var = 'genome_name')
else dplyr::select(., k_number, taxonomy) %>%
tibble::column_to_rownames(var = 'taxonomy')} %>%
t() %>%
dplyr::as_tibble(~ vctrs::vec_as_names(repair = "unique", quiet = TRUE))
x_j.tibble <- patt.kegg_modules %>%
dplyr::bind_cols(input_data) %>% # binding COLUMNS, not ROWS of the input data with the patt.kegg_modules tibble
dplyr::group_by(step, k_numbers) %>%
dplyr::summarize(dplyr::across(!1:3, ~ as.integer(stringr::str_detect(
string = .x, pattern = k_numbers))), .groups = 'keep') %>%
dplyr::ungroup(k_numbers) %>%
dplyr::select(-c(k_numbers)) %>%
dplyr::summarize(dplyr::across(dplyr::everything(), ~ sum(.x)), .groups = 'drop') %>%
dplyr::select(-step)
x_j.tibble_list <- list()
x_j.tibble_list <- purrr::map(1:length(x_j.tibble), ~ {
x_j.tibble_list[[.x]] <- x_j.tibble[[.x]]
}) %>%
purrr::set_names(nm = names(x_j.tibble))
return(x_j.tibble_list)
}
map_modules_to <- function(x_j.tibble_list, userData, strict = FALSE) {
present_and_missing_modules_list <- list()
present_and_missing_modules_list <- purrr::map(1:length(x_j.tibble_list), ~ {
present_and_missing_modules_list[[.x]] <- all_kegg_modules %>%
dplyr::ungroup() %>%
dplyr::mutate(x_j = x_j.tibble_list[[.x]]) %>%
tibble::add_column(taxonomy = userData$taxonomy[.x], .before = 1) %>%
{if (unique(userData$data_type) == 'genome') tibble::add_column(., 'genome_name' = userData$genome_name[.x], .after = 1)
else tibble::add_column(., 'metagenome_name' = userData$metagenome_name[.x], .after = 1)} %>%
tibble::add_column(domain = get_domain(userData$taxonomy[.x]), .after = 1) %>%
get_lowest_taxonomy() %>%
dplyr::mutate(`Module step present` = dplyr::case_when(n == x_j ~ TRUE, n != x_j ~ FALSE),
p_j = userData$completeness[.x]) %>%
dplyr::arrange(step) %>%
dplyr::group_by(module) %>%
{if (strict == TRUE) dplyr::filter(., !all(`Module step present` == FALSE)) else (.)} # filters out pathways for which there is no evidence of their presence in the gene annotations
}) %>%
purrr::set_names(nm = names(x_j.tibble_list))
return(present_and_missing_modules_list)
}
get_domain <- function(taxonomy) { #NOTE: some columns of bact_ & arch_phylo_key contain NA, hence the na.omit()
if (purrr::some(1:6, ~ {
any(stringr::str_detect(na.omit(bact_phylo_key2[[.x]]), stringr::regex(paste0('^', taxonomy, '$'), ignore_case = TRUE)))})) {
domain = 'Bacteria'
} else if (purrr::some(1:6, ~ {
any(stringr::str_detect(na.omit(arch_phylo_key2[[.x]]), stringr::regex(paste0('^', taxonomy, '$'), ignore_case = TRUE)))})) {
domain = 'Archaea'
} else {
domain = 'Unknown'
}
return(domain)
}
get_lowest_taxonomy <- function(.data) {
if (unique(.data$domain) == 'Bacteria') {
search_tree(.data, bact_phylo_key2, .list_num = 1, .domain = 'Bacteria_')
} else if (unique(.data$domain) == 'Archaea') {
search_tree(.data, arch_phylo_key2, .list_num = 2, .domain = 'Archaea_')
} else {
dplyr::mutate(.data, lowest = 'Unknown')
}
}
search_tree <- function(.data, taxonomy_key, .list_num, .domain) {
indices <- taxonomy_key %>% #find out exactly where taxonomy matches are in taxonomic table keys
purrr::map(~ {stringr::str_detect(.x, stringr::regex(paste0('^', unique(.data$taxonomy), '$'), ignore_case = TRUE))}) %>%
purrr::map(which) %>%
purrr::keep(~ !is_empty(.x))
if (!purrr::is_empty(indices)) { #extract taxonomy from key, including higher levels up to root (domain)
possible_taxa <- taxonomy_key %>%
dplyr::slice(purrr::pluck(indices, 1, 1)) %>%
dplyr::select(purrr::pluck(indices, names, 1):6)
for (.x in seq_along(possible_taxa)) {
if (is.na(possible_taxa[[.x]][1])) {
next
} else {
if (any(stringr::str_detect(
colnames(priors_list2[[.list_num]][[paste0(.domain, names(possible_taxa)[.x])]]),
possible_taxa[[.x]][1]))) {
.data <- .data %>%
dplyr::mutate(lowest = possible_taxa[[.x]][1])
break
} else {
.data <- .data %>%
dplyr::mutate(lowest = 'Unknown')
}
}
}
} else {
.data <- .data %>%
dplyr::mutate(lowest = 'Unknown')
}
return(.data)
}
## pulls y_j, m_j, alpha, and beta
get_parameters <- function(data_list, moduleVector = NULL)  {
input_list <- list(bact_list = data_list %>% purrr::keep(~ .x$domain[1] == 'Bacteria'),
arch_list = data_list %>% purrr::keep(~ .x$domain[1] == 'Archaea'),
unk_list = data_list %>% purrr::keep(~ .x$domain[1] == 'Unknown'))
res_list <- list() #1:2 for bact and arch_lists; unk needs its own section
purrr::map_if(seq_along(input_list), ~ length(input_list[[.x]]) != 0, ~ {
res_list[[.x]] <- list()
purrr::map(1:length(input_list[[.x]]), function(cur) {
cur_org <- input_list[[.x]][[cur]]
cur_org <- cur_org %>% #cur_org is a grouped tibble for the current MAG/metagenome contig cluster
dplyr::ungroup() %>%
{if (!is.null(moduleVector)) dplyr::filter(., module %in% moduleVector) else (.)}
cur_org.list <- list(present = dplyr::filter(cur_org, `Module step present` == TRUE),
absent = dplyr::filter(cur_org, `Module step present` == FALSE)) # split cur_org into a list of 2 tibbles based on module presence/absence
full_indices <- purrr::map_depth(priors_list2[[.x]], .depth = 1, function(.cur_priors) {
purrr::map_lgl(colnames(.cur_priors), function(.column_name) {
stringr::str_detect(.column_name, stringr::regex(paste0('^', cur_org$lowest[1], '$')))
}) %>%
which()
})
#1st: gets position of list element with first regex match; 2nd: gets position of column within list element containing first regex match
lowest_index <- c(purrr::detect_index(full_indices, ~ !purrr::is_empty(.x)), purrr::detect(full_indices, ~ !purrr::is_empty(.x)))
cur_org.list[['absent']] <- cur_org.list[['absent']] %>%
dplyr::mutate(y_j = get_yj(modules_contained_y[[names(full_indices)[lowest_index[1]]]], cur_org$lowest[1], step_col = .$step),
m_j = get_mj(collection_lengths_m[[names(full_indices)[lowest_index[1]]]], cur_org$lowest[1])) %>%
dplyr::left_join(dplyr::select(priors_list2[[.x]][[names(full_indices)[lowest_index[1]]]], step, lowest_index[2]) %>%
tidyr::separate_rows(dplyr::everything(), sep = ' '), by = 'step') %>%
dplyr::rename(parameters = 16) %>% ### POSITION-BASED STEP- MUST CHANGE IF CODE IS UPDATED
tidyr::separate(parameters, into = c('alpha', 'beta'), sep = ';') %>%
dplyr::mutate(dplyr::across(c(alpha, beta), ~ as.numeric(.x)))
cur_org.list[['present']] <- cur_org.list[['present']] %>%
dplyr::mutate(y_j = NA, m_j = NA, alpha = NA, beta = NA)
res_list[[.x]][[cur]] <- cur_org.list[['absent']] %>%
dplyr::bind_rows(cur_org.list[['present']]) %>%
dplyr::arrange(module, step)
#return(res_list)
})
}) %>%
rlang::squash() %>%
suppressWarnings() %>%
purrr::keep(~ is_tibble(.x))
}
get_yj <- function(y_list,  taxonomy, step_col = NULL) {
y_j <- y_list %>%
dplyr::select(dplyr::matches(stringr::regex(taxonomy), ignore.case = TRUE), step, module) %>%
dplyr::filter(step %in% step_col) %>%
dplyr::select(-c(module, step))
return(y_j[[1]])
}
get_mj <- function(m_list, taxonomy) {
m_j <- m_list %>%
dplyr::filter(.[[1]] == taxonomy) %>%
select(-1)
return(m_j[[1]])
}
## pulls y_j, m_j, alpha, and beta
get_parameters <- function(data_list, moduleVector = NULL)  {
input_list <- list(bact_list = data_list %>% purrr::keep(~ .x$domain[1] == 'Bacteria'),
arch_list = data_list %>% purrr::keep(~ .x$domain[1] == 'Archaea'),
unk_list = data_list %>% purrr::keep(~ .x$domain[1] == 'Unknown'))
res_list <- list() #1:2 for bact and arch_lists; unk needs its own section
purrr::map_if(seq_along(input_list), ~ length(input_list[[.x]]) != 0, ~ {
res_list[[.x]] <- list()
purrr::map(1:length(input_list[[.x]]), function(cur) {
cur_org <- input_list[[.x]][[cur]]
cur_org <- cur_org %>% #cur_org is a grouped tibble for the current MAG/metagenome contig cluster
dplyr::ungroup() %>%
{if (!is.null(moduleVector)) dplyr::filter(., module %in% moduleVector) else (.)}
cur_org.list <- list(present = dplyr::filter(cur_org, `Module step present` == TRUE),
absent = dplyr::filter(cur_org, `Module step present` == FALSE)) # split cur_org into a list of 2 tibbles based on module presence/absence
message('Working on: ', cur_org$lowest[1])
full_indices <- purrr::map_depth(priors_list2[[.x]], .depth = 1, function(.cur_priors) {
purrr::map_lgl(colnames(.cur_priors), function(.column_name) {
stringr::str_detect(.column_name, stringr::regex(paste0('^', cur_org$lowest[1], '$')))
}) %>%
which()
})
#1st: gets position of list element with first regex match; 2nd: gets position of column within list element containing first regex match
lowest_index <- c(purrr::detect_index(full_indices, ~ !purrr::is_empty(.x)), purrr::detect(full_indices, ~ !purrr::is_empty(.x)))
cur_org.list[['absent']] <- cur_org.list[['absent']] %>%
dplyr::mutate(y_j = get_yj(modules_contained_y[[names(full_indices)[lowest_index[1]]]], cur_org$lowest[1], step_col = .$step),
m_j = get_mj(collection_lengths_m[[names(full_indices)[lowest_index[1]]]], cur_org$lowest[1])) %>%
dplyr::left_join(dplyr::select(priors_list2[[.x]][[names(full_indices)[lowest_index[1]]]], step, lowest_index[2]) %>%
tidyr::separate_rows(dplyr::everything(), sep = ' '), by = 'step') %>%
dplyr::rename(parameters = 16) %>% ### POSITION-BASED STEP- MUST CHANGE IF CODE IS UPDATED
tidyr::separate(parameters, into = c('alpha', 'beta'), sep = ';') %>%
dplyr::mutate(dplyr::across(c(alpha, beta), ~ as.numeric(.x)))
cur_org.list[['present']] <- cur_org.list[['present']] %>%
dplyr::mutate(y_j = NA, m_j = NA, alpha = NA, beta = NA)
res_list[[.x]][[cur]] <- cur_org.list[['absent']] %>%
dplyr::bind_rows(cur_org.list[['present']]) %>%
dplyr::arrange(module, step)
#return(res_list)
})
}) %>%
rlang::squash() %>%
suppressWarnings() %>%
purrr::keep(~ is_tibble(.x))
}
#####################################################################################################
#04/06/21
module_nums <- all_kegg_modules$module[sample(857, 25)]
module_nums
random_sampling_results <- MetaPredict(rs.test2, moduleVector = module_nums)
random_sampling_results <- MetaPredict(rs.test, moduleVector = module_nums)
View(priors_list2)
View(priors_list2[["Archaea"]][["Archaea_Genus"]])
View(priors_list2[["Unknown"]][["Unknown"]])
View(modules_contained_y)
View(modules_contained_y[["Unknown"]])
View(modules_contained_y[["Archaea_Domain"]])
View(rs.test %>% select(-k_number))
View(rs.test %>% select(-k_number, -gene_name))
unk.test <- rs.test %>% filter(taxonomy == 'unidentified taxonomy')
unk.test
random_samp.unk <- MetaPredict(unk.test, moduleVector = module_nums)
random_samp.unk
View(rs.test %>% select(-k_number, -gene_name))
#
rs.test %>%
get_lowest_taxonomy()
rs.test
#
rs.test %>%
get_lowest_taxonomy()
#
rs.test %>%
mutate(domain = get_domain(taxonomy))
get_domain
#
rs.test %>%
mutate(domain = map_chr(taxonomy, get_domain))
#
rs.test %>%
mutate(domain = map_chr(taxonomy, get_domain)) %>%
get_lowest_taxonomy() %>% View()
get_lowest_taxonomy()
get_lowest_taxonomy
#
rs.test %>%
mutate(domain = map_chr(taxonomy, get_domain)) %>%
rowwise() %>%
get_lowest_taxonomy() %>% View()
rs.test
#
rs.test %>%
mutate(domain = map_chr(taxonomy, get_domain)) %>%
group_by(taxonomy) %>%
group_split() %>%
map(~ get_lowest_taxonomy(.x)) %>%
bind_rows() %>%
View()
#
rs.test.w_lowest <- rs.test %>%
mutate(domain = map_chr(taxonomy, get_domain)) %>%
group_by(taxonomy) %>%
group_split() %>%
map(~ get_lowest_taxonomy(.x)) %>%
bind_rows()
random_sampling_results <- MetaPredict(rs.test, moduleVector = module_nums)
View(rs.test.w_lowest)
View(bact_phylo_key2)
bact_phylo_key2 %>% filter(!Domain == 'Archaea')
#### 4/06/21
# FOUND AN ARCHAEA ROW IN THE BACT.PHYLO.KEY... WTF. THAT WAS WHAT WAS CAUSING A DOMAIN ERROR
# IN THE METAGENOME, THE TAXONOMY "ARCHAEA" WAS BEING LABELLED WITH DOMAIN 'BACTERIA' BY GET_DOMAIN() BECAUSE THERE WAS AN ARCHAEA ROW IN THE BACT.PHYLO.KEY!!
bact_phylo_key2 %>%
filter(Domain != 'Archaea')
#### 4/06/21
# FOUND AN ARCHAEA ROW IN THE BACT.PHYLO.KEY... WTF. THAT WAS WHAT WAS CAUSING A DOMAIN ERROR
# IN THE METAGENOME, THE TAXONOMY "ARCHAEA" WAS BEING LABELLED WITH DOMAIN 'BACTERIA' BY GET_DOMAIN() BECAUSE THERE WAS AN ARCHAEA ROW IN THE BACT.PHYLO.KEY!!
bact_phylo_key2 <- bact_phylo_key2 %>%
filter(Domain != 'Archaea')
arch_phylo_key2 %>% filter(Domain != 'Bacteria')
View(arch_phylo_key2)
# looked over arch.phylo.key as well and found one row that is NA in every column ... why?
arch_phylo_key2 %>%
filter(!is.na(Domain))
View(arch_phylo_key2)
# looked over arch.phylo.key as well and found one row that is NA in every column ... why?
arch_phylo_key2 %>%
filter(!is.na(Domain))
# looked over arch.phylo.key as well and found one row that is NA in every column ... why?
arch_phylo_key2 <- arch_phylo_key2 %>%
filter(!is.na(Domain))
save(all_kegg_modules, arch_phylo_key2, bact_phylo_key2, collection_lengths_m, modules_contained_y, patt.kegg_modules, priors_list2, n, file = '~/Documents/metapredict-construct-yl/CURRENT-PRIORS-DATA/CURRENT-METAPREDICT-INTERNAL-DATA-040621.RData')
usethis::use_data(all_kegg_modules, arch_phylo_key2, bact_phylo_key2, collection_lengths_m, modules_contained_y, patt.kegg_modules, priors_list2, n, internal = TRUE)
devtools::document()
devtools::install_github('d-mcgrath/MetaPredict-HPC', subdir = 'MetaPredict',
auth_token = '707963548b6b2faf537f0e9790b9156853752d16')
