select(-1)
return(m_j[[1]])
}
#' @importFrom magrittr "%>%"
# p(x_j|k) = CONDITIONAL PROBABILITY that X_j = x_j given that K_j = n
# n = length of module (# genes)
# x_j = THE NUMBER of genes from the module present in an input FRAGMENT f_j (the OBSERVED value of X_j)
# k_j = OBSERVED VALUE OF K_j, which is the NUMBER of MP genes in a genome g_j, of which f_j is a fragment
get_p.xj_n <- function(n, x_j, p_j) {
p.xj_n <- choose(n, x_j) * p_j^x_j * (1 - p_j)^(n - x_j)
return(p.xj_n)
}
get_p.xj_k <- function(n, x_j, p_j) {
k <- x_j:(n - 1)
p.xj_k <- choose(k, x_j) * p_j^x_j * (1 - p_j)^(k - x_j)
return(p.xj_k)
}
# p(x_j|nbar) = CONDITIONAL PROBABILITY that X_j = x_j given that K_j != n
#requires
get_p.xj_nbar <- function(n, x_j, p_j, pj.k) {
p.xj_k <- get_p.xj_k(n, x_j, p_j)
p.xj_nbar = sum(p.xj_k * pj.k)
return(p.xj_nbar)
}
## m_l = length of collection C_l
## m_j = length of collection C_j
LogL.betabinomial <- function(params, y_l, n, m_l) {
alpha <- params[1]
beta <- params[2]
sum(-lgamma(alpha + beta) - lgamma(alpha + y_l)
- lgamma(beta + (n * m_l) - y_l) + lgamma(alpha)
+ lgamma(beta) + lgamma(alpha + beta + (n * m_l)))
}
## m_l = length of collection C_l
## m_j = length of collection C_j
## C_j = collection of known genomes to which fragments f_j belong
## n = length of module (# genes)
## alpha + beta MLEs
## k_j = OBSERVED VALUE OF K_j, which is the NUMBER of MP genes in a genome g_j, of which f_j is a fragment
get_pj.k_betabinomial <- function(alpha, beta, y_j, n, m_j, x_j) { # k = seq_along(x_j:(n - 1)) # x_j should never equal n; if it does, the module step is complete/present
k <- x_j:(n - 1)
A_j <- alpha + y_j
B_j <- beta + (n * m_j) - y_j
pj.k <- exp(lgamma(A_j + B_j) + lgamma(A_j + k) + lgamma(B_j + n - k) - lgamma(A_j) - lgamma(B_j) - lgamma(A_j + B_j + n))
return(pj.k)
}
get_pj.n_betabinomial <- function(alpha, beta, y_j, n, m_j, x_j) {
k <- n
A_j <- alpha + y_j
B_j <- beta + (n * m_j) - y_j
pj.n <- exp(lgamma(A_j + B_j) + lgamma(A_j + k) + lgamma(B_j + n - k) - lgamma(A_j) - lgamma(B_j) - lgamma(A_j + B_j + n))
return(pj.n)
}
calculate_posterior <- function(p.xj_n, p.xj_nbar, alpha, beta, y_j, n, m_j, x_j) {
pj.n <- get_pj.n_betabinomial(alpha, beta, y_j, n, m_j, x_j)
p.n_xj <- (p.xj_n * pj.n) / ((p.xj_n * pj.n) + (p.xj_nbar * (1 - pj.n)))
return(p.n_xj)
}
# Calculate the posterior probability that a module step is present,
# given the genome completeness estimate p
get_posteriors <- function(modules_list) {
posterior_results <- list()
posterior_results <- purrr::map(seq_along(modules_list), ~ {
posterior_results[[.x]] <- modules_list[[.x]] %>%
dplyr::rowwise() %>%
dplyr::mutate(pj.k = list(get_pj.k_betabinomial(alpha, beta, y_j, n, m_j, x_j)),
p.xj_nbar = get_p.xj_nbar(n, x_j, p_j, pj.k),
p.xj_n = list(get_p.xj_n(n, x_j, p_j)), # VERIFY THAT pj.k IS EQUIVALENT TO "p_j" ## UPDATE: THEY ARE NOT EQUIVALENT.
probability = calculate_posterior(p.xj_n, p.xj_nbar, alpha, beta, y_j, n, m_j, x_j)) %>%
dplyr::select(-c(n, x_j, p_j, y_j, m_j, alpha, beta, pj.k, p.xj_nbar, p.xj_n))
})
return(posterior_results)
}
# issue with 15 vs 16 columns when using metagenome --- debugging ----
x_j.list <- get.x_j(test.filt)
load('R/sysdata.rda')
# issue with 15 vs 16 columns when using metagenome --- debugging ----
x_j.list <- get.x_j(test.filt)
test.filt <- test %>% group_by(taxonomy) %>% filter((str_count(k_number, pattern = ' ') + 1) >= 2000 & (str_count(k_number, pattern = ' ') + 1) < 8000)
test.filt <- test %>% group_by(taxonomy) %>% filter((str_count(k_number, pattern = ' ') + 1) >= 2000 & (str_count(k_number, pattern = ' ') + 1) < 4000)
test.filt <- test %>% group_by(taxonomy) %>% filter((str_count(k_number, pattern = ' ') + 1) >= 2000 & (str_count(k_number, pattern = ' ') + 1) < 3000)
# issue with 15 vs 16 columns when using metagenome --- debugging ----
x_j.list <- get.x_j(test.filt)
results <- map_modules_to(x_j.list, test.filt)# this function should be split into 2 parts
warnings()
#' This function is used to read in user metagenome data gene prediction data with associated taxonomic annotations,
#' and KEGG Orthology HMM/Blast data. Both inputs must be in the form of flatfiles, default is TSV format.
#' @param gene_input The full or relative path to a single flatfile with gene predictions and their associated taxonomic annotations.
#' Columns with taxonomy should include one more of the following: Genus, Family, Order, Class, Phylum, Domain
#' @param ko_input The full or relative path to a  single flatfile with HMM/Blast results which include KEGG Orthology terms in a column titled 'KO'
#' and E-values in a column titled 'E-value'
#' @param metadata A CSV flatfile containing the estimated metagenome completeness of all input metagenomes
#' @param evalue The desired E-value cutoff for HMM/Blast KEGG Orthology hits. Default is 0.001
#' @param gene_delim The delimiter of the input gene prediction with taxonomic annotation flatfile. Default is tab
#' @param ko_delim The delimiter of the input KEGG Orthology prediction flatfile. Default is tab
#' @param kofamscan If the input KEGG Orthology flatfile is direct output from Kofamscan, set this argument to TRUE, otherwise FALSE. Default is TRUE
#' @importFrom magrittr "%>%"
#' @export
read_metagenome_data <- function(gene_input = NULL, ko_input = NULL, metadata = NULL, gene_df = FALSE, ko_df = FALSE, metadata_df = FALSE, cutoff = 1e-3, gene_delim = '\t', ko_delim = '\t', kofamscan = TRUE, cat = TRUE, custom_knumber_ColNames = NULL, custom_anno_ColNames = NULL) {
if (all(!is.null(metadata) & metadata_df == FALSE)) {
#option must be added to have metagenome_name for each metagenome and its completeness
suppressWarnings(metadata_tbl <- readr::read_csv(metadata, col_types = readr::cols()))
if (length(colnames(metadata_tbl)) > 2) {
cli::cli_alert_danger('Error: expected a maximum of two columns: metagenome_name and completeness columns.')
stop()
}
metadata_tbl <- metadata_tbl %>%
dplyr::rename_if(~ is.character(.x), ~ 'metagenome_name') %>%
dplyr::rename_if(is.numeric, ~ 'completeness') %>%
dplyr::mutate(completeness = completeness / 100)
if (any(metadata_tbl$completeness > 1 | metadata_tbl$completeness < 0)) {
cli::cli_alert_danger('Error: completeness column contains one ore more values with a percentage greater than 100 or less than 0. Please make sure all percentage values are between 0 and 100.')
stop()
}
} else if (all(is.null(metadata) & is.data.frame(metadata_df))) {
if (all(c('metagenome_name', 'completeness') %in% colnames(metadata_df))) {
metadata_tbl <- metadata_df %>%
dplyr::select(metagenome_name, completeness) %>%
dplyr::mutate(completeness = completeness / 100)
if (any(metadata_tbl$completeness > 1 | metadata_tbl$completeness < 0)) {
cli::cli_alert_danger('Error: completeness column contains one ore more values with a percentage greater than 100 or less than 0. Please make sure all percentage values are between 0 and 100.')
stop()
}
} else {
cli::cli_alert_danger('Error: Does your metadata dataframe contain the four columns genome_name, taxonomy, completeness, and filename?')
stop()
}
} else if (all(!is.null(metadata) & is.data.frame(metadata_df))) {
cli::cli_alert_danger('Error: Either a gene input flatfile or a gene dataframe is required. Both types of inputs were detected. Make sure to use either the metadata or metadata_df argument, not both.')
stop()
} else if (all(is.null(metadata) & metadata_df == FALSE)) {
stop(cli::cli_alert_danger('Metadata including estimated metagenome completeness information required. This should be a value between 0 and 100. Please provide a CSV metadata flatfile or metadata dataframe consisting of a column of the estimated completeness of the metagenome. Optionally add a second column metagenome_name with the metagenome name (column order does not matter).'))
} else {
cli::cli_alert_danger('Something went wrong. Please see usage() for instructions to run MetaPredict.')
stop()
}
taxonomic_lvls <- c('Genus', 'Family', 'Order', 'Class', 'Phylum', 'Domain')
tax_cols <- c('Genus' = NA, 'Family' = NA, 'Order' = NA, 'Class' = NA, 'Phylum' = NA, 'Domain' = NA)
# read in gene flatfile, or optionally a dataframe containing the gene information
if (all(!is.null(gene_input) & gene_df == FALSE)) {
cli::cli_h1('Reading metagenomic data into MetaPredict')
gene_table <- suppressWarnings(readr::read_delim(gene_input, col_types = readr::cols(),
delim = gene_delim))
} else if (all(!is.null(gene_input) & is.data.frame(gene_df))) {
cli::cli_alert_danger('Error: Either a gene input flatfile or a gene dataframe is required. Both types of inputs were detected. Make sure to use either the gene_input or gene_df argument, not both.')
stop()
} else if (all(is.null(gene_input) & is.data.frame(gene_df))) {
gene_table <- gene_df
} else {
cli::cli_alert_danger('Error: gene input flatfile/gene dataframe not detected. Make sure you have given the path to a flatfile for the gene_input argument, or have provided the name of a dataframe object for the gene_df argument.')
stop()
}
###############
gene_table <- gene_table %>%
dplyr::rename_with(~ taxonomic_lvls[stringr::str_detect(taxonomic_lvls, stringr::regex(., ignore_case = TRUE))], .cols = dplyr::contains(taxonomic_lvls)) %>%
{if (cat == TRUE) tidy_cat_taxa(., taxonomic_lvls = taxonomic_lvls, tax_cols = tax_cols)
else if (!is.null(custom_anno_ColNames)) tidy_custom_taxa(., cutoff = cutoff)
else stop(cli::cli_alert_danger('Error: Input format does not match any of the accepted formats. Please see usage()'))}
# read in gene flatfile, or optionally a dataframe containing the gene information
if (all(!is.null(ko_input) & ko_df == FALSE)) {
cli::cli_h1('Reading KEGG Orthology data into MetaPredict')
ko_table <- suppressWarnings(readr::read_delim(ko_input, col_types = readr::cols(),
delim = ko_delim))
} else if (all(!is.null(ko_input) & is.data.frame(ko_df))) {
cli::cli_alert_danger('Error: Either a KEGG Orthology input flatfile or a KEGG Orthology dataframe is required. Both types of inputs were detected. Make sure to use either one or the other input type, not both.')
stop()
} else if (all(is.null(ko_input) & is.data.frame(ko_df))) {
ko_table <- ko_df
} else {
cli::cli_alert_danger('Error: Kegg Orthology input flatfile/gene dataframe not detected. Make sure you have given the path to a flatfile for the ko_input argument, or have provided the name of a dataframe object for the ko_df argument.')
stop()
}
###############
ko_table <- ko_table %>%
{if (kofamscan == TRUE) tidy_kofam.mg(., cutoff = cutoff)
else if (!is.null(custom_knumber_ColNames)) tidy_custom_anno(., cutoff = cutoff, input_type = 'metagenome_name')
else stop(cli::cli_alert_danger('Error message')) }
if (!('metagenome_name' %in% colnames(metadata_tbl)) & !('metagenome_name' %in% colnames(ko_table))) {
if (!is.null(ko_input)) {
default_name <- sub('.*\\/(.*)\\..*', '\\1', ko_input, perl = T)
} else if (is.data.frame(ko_df)) {
default_name <- deparse(substitute(ko_df))
} else {
stop(cli::cli_alert_danger('Error: Could not create default name for metagenome. Make sure input data and arguments were formatted properly.'))
}
cli::cli_alert_info('Metagenome name(s) not provided/detected. Using default metagenome name: {default_name}')
} else {default_name <- NULL}
#need this somewhere .... #dplyr::filter(!(duplicated(k_number)))
gene_table <- gene_table %>%
merge_tables(ko_table, metadata_tbl, default_name = default_name)
cli::cli_alert_success('Parsed predicted genes and gene taxonomic annotations')
cli::cli_alert_success('Parsed HMM/Blast hits and E-values')
cli::cli_alert_info('Used E-value cutoff: {cutoff}')
return(gene_table)
}
tidy_kofam.mg <- function(.data, cutoff = 1e-3) {
.data %>%
dplyr::filter(!stringr::str_detect(`E-value`, '-----')) %>%
{if (all(c('E-value', 'KO', 'gene name') %in% colnames(.))) dplyr::select(., `E-value`, KO, `gene name`)
else stop(cli::cli_alert_danger(
"Error: Columns 'E-value', 'KO', and 'gene name' not detected. These columns are required to read in Kofamscan output files."))} %>%
dplyr::mutate(`E-value` = as.numeric(`E-value`)) %>%
dplyr::filter(`E-value` <= cutoff | `E-value` == 0) %>%
dplyr::select(KO, `gene name`) %>%
dplyr::rename(gene_name = `gene name`, k_number = KO) %>%
dplyr::filter(!is.na(k_number))
}
tidy_cat_taxa <- function(.data, taxonomic_lvls, tax_cols) {
.data %>%
dplyr::rename_at(dplyr::vars(dplyr::contains('Superkingdom')), ~ paste0('Domain')) %>%
dplyr::rename_at(dplyr::vars(dplyr::contains('ORF')), ~ paste0('ORF')) %>%
tibble::add_column(!!!tax_cols[!names(tax_cols) %in% names(.)]) %>%
dplyr::mutate(Domain = dplyr::case_when(Domain == 'not classified' ~ NA_character_,
lineage == 'no taxid found' ~ NA_character_,
lineage == 'no hit to database' ~ NA_character_,
TRUE ~ Domain)) %>%
dplyr::mutate(dplyr::across(dplyr::all_of(taxonomic_lvls), ~ sub('not classified', NA, .x)),
dplyr::across(dplyr::all_of(taxonomic_lvls), ~ sub('.*\\*$', NA, .x)),
taxonomy = dplyr::coalesce(Genus, Family, Order, Class, Phylum, Domain)) %>% #, #coalesce takes the lowest tax level as input
#taxonomy = stringr::str_replace_all(taxonomy,
#                                    stringr::regex(c('Candidatus ' = '', '\\*+' = '',
#                                                     'candidate division ' = ''),
#                                                   ignore_case = TRUE))) %>%
dplyr::rename(gene_name = ORF) %>%
dplyr::select(gene_name, taxonomy) %>%
dplyr::filter(taxonomy != 'Viruses')
}
#fn to join gene annotation, contig/scaffold taxonomic annotation, and metagenome completeness tibbles
merge_tables <- function(.data, ko_table, metadata_tbl, default_name = NULL) {
.data %>%
dplyr::full_join(ko_table, by = 'gene_name') %>%
dplyr::filter(!(is.na(k_number))) %>%
dplyr::mutate(taxonomy = dplyr::case_when(
is.na(taxonomy) ~ 'unidentified taxonomy',
TRUE ~ taxonomy)) %>%
dplyr::arrange(taxonomy) %>%
dplyr::group_by(taxonomy) %>%
dplyr::summarize(k_number = paste0(k_number, collapse = ' '),
gene_name = paste0(gene_name, collapse = ' '),
taxonomy = unique(taxonomy),
.groups = 'keep') %>%
{if (!is.null(default_name)) dplyr::mutate(., metagenome_name = default_name)
else (.)} %>%
dplyr::mutate(data_type = 'metagenome',# requires if/else statement - names might be provided by user
p_j = metadata_tbl$completeness[1])
}
tidy_custom_taxa <- function(.data, cutoff = 1e-3) {
taxonomic_lvls <- c('Genus', 'Family', 'Order', 'Class', 'Phylum', 'Domain')
tax_cols <- c('Genus' = NA, 'Family' = NA, 'Order' = NA, 'Class' = NA, 'Phylum' = NA, 'Domain' = NA)
.data %>%
{if ('gene_name' %in% colnames(.) & any(taxonomic_lvls %in% colnames(.))) dplyr::select(., gene_name, dplyr::contains(taxonomic_lvls))
else stop(cli::cli_alert_danger(
"Error: Custom taxonomy file must contain column 'gene_name' and at least one column with a taxonomic level (Genus, Family, Order, Class, and/or Phylum).
The lowest taxonomic level down to Genus will be used. Please see usage() for more information"))} %>%
purrr::modify(taxonomic_lvls, function(.col) {dplyr::rename(., dplyr::across(dplyr::contains(.col), ~ .col))}) %>%
tibble::add_column(!!!tax_cols[!names(tax_cols) %in% names(.)]) %>%
dplyr::mutate(dplyr::across(dplyr::all_of(taxonomic_lvls), ~ sub('not classified', NA, .x)),
taxonomy = dplyr::coalesce(Genus, Family, Order, Class, Phylum, Domain)) %>% #, #coalesce takes the lowest tax level as input
#taxonomy = stringr::str_replace_all(taxonomy,
#                                    stringr::regex(c('Candidatus ' = '', '\\*+' = '',
#                                                     'candidate division ' = ''),
#                                                   ignore_case = TRUE))) %>%
dplyr::select(gene, taxonomy)
}
test.filt
#' This function is used to read in user metagenome data gene prediction data with associated taxonomic annotations,
#' and KEGG Orthology HMM/Blast data. Both inputs must be in the form of flatfiles, default is TSV format.
#' @param gene_input The full or relative path to a single flatfile with gene predictions and their associated taxonomic annotations.
#' Columns with taxonomy should include one more of the following: Genus, Family, Order, Class, Phylum, Domain
#' @param ko_input The full or relative path to a  single flatfile with HMM/Blast results which include KEGG Orthology terms in a column titled 'KO'
#' and E-values in a column titled 'E-value'
#' @param metadata A CSV flatfile containing the estimated metagenome completeness of all input metagenomes
#' @param evalue The desired E-value cutoff for HMM/Blast KEGG Orthology hits. Default is 0.001
#' @param gene_delim The delimiter of the input gene prediction with taxonomic annotation flatfile. Default is tab
#' @param ko_delim The delimiter of the input KEGG Orthology prediction flatfile. Default is tab
#' @param kofamscan If the input KEGG Orthology flatfile is direct output from Kofamscan, set this argument to TRUE, otherwise FALSE. Default is TRUE
#' @importFrom magrittr "%>%"
#' @export
read_metagenome_data <- function(gene_input = NULL, ko_input = NULL, metadata = NULL, gene_df = FALSE, ko_df = FALSE, metadata_df = FALSE, cutoff = 1e-3, gene_delim = '\t', ko_delim = '\t', kofamscan = TRUE, cat = TRUE, custom_knumber_ColNames = NULL, custom_anno_ColNames = NULL) {
if (all(!is.null(metadata) & metadata_df == FALSE)) {
#option must be added to have metagenome_name for each metagenome and its completeness
suppressWarnings(metadata_tbl <- readr::read_csv(metadata, col_types = readr::cols()))
if (length(colnames(metadata_tbl)) > 2) {
cli::cli_alert_danger('Error: expected a maximum of two columns: metagenome_name and completeness columns.')
stop()
}
metadata_tbl <- metadata_tbl %>%
dplyr::rename_if(~ is.character(.x), ~ 'metagenome_name') %>%
dplyr::rename_if(is.numeric, ~ 'completeness') %>%
dplyr::mutate(completeness = completeness / 100)
if (any(metadata_tbl$completeness > 1 | metadata_tbl$completeness < 0)) {
cli::cli_alert_danger('Error: completeness column contains one ore more values with a percentage greater than 100 or less than 0. Please make sure all percentage values are between 0 and 100.')
stop()
}
} else if (all(is.null(metadata) & is.data.frame(metadata_df))) {
if (all(c('metagenome_name', 'completeness') %in% colnames(metadata_df))) {
metadata_tbl <- metadata_df %>%
dplyr::select(metagenome_name, completeness) %>%
dplyr::mutate(completeness = completeness / 100)
if (any(metadata_tbl$completeness > 1 | metadata_tbl$completeness < 0)) {
cli::cli_alert_danger('Error: completeness column contains one ore more values with a percentage greater than 100 or less than 0. Please make sure all percentage values are between 0 and 100.')
stop()
}
} else {
cli::cli_alert_danger('Error: Does your metadata dataframe contain the four columns genome_name, taxonomy, completeness, and filename?')
stop()
}
} else if (all(!is.null(metadata) & is.data.frame(metadata_df))) {
cli::cli_alert_danger('Error: Either a gene input flatfile or a gene dataframe is required. Both types of inputs were detected. Make sure to use either the metadata or metadata_df argument, not both.')
stop()
} else if (all(is.null(metadata) & metadata_df == FALSE)) {
stop(cli::cli_alert_danger('Metadata including estimated metagenome completeness information required. This should be a value between 0 and 100. Please provide a CSV metadata flatfile or metadata dataframe consisting of a column of the estimated completeness of the metagenome. Optionally add a second column metagenome_name with the metagenome name (column order does not matter).'))
} else {
cli::cli_alert_danger('Something went wrong. Please see usage() for instructions to run MetaPredict.')
stop()
}
taxonomic_lvls <- c('Genus', 'Family', 'Order', 'Class', 'Phylum', 'Domain')
tax_cols <- c('Genus' = NA, 'Family' = NA, 'Order' = NA, 'Class' = NA, 'Phylum' = NA, 'Domain' = NA)
# read in gene flatfile, or optionally a dataframe containing the gene information
if (all(!is.null(gene_input) & gene_df == FALSE)) {
cli::cli_h1('Reading metagenomic data into MetaPredict')
gene_table <- suppressWarnings(readr::read_delim(gene_input, col_types = readr::cols(),
delim = gene_delim))
} else if (all(!is.null(gene_input) & is.data.frame(gene_df))) {
cli::cli_alert_danger('Error: Either a gene input flatfile or a gene dataframe is required. Both types of inputs were detected. Make sure to use either the gene_input or gene_df argument, not both.')
stop()
} else if (all(is.null(gene_input) & is.data.frame(gene_df))) {
gene_table <- gene_df
} else {
cli::cli_alert_danger('Error: gene input flatfile/gene dataframe not detected. Make sure you have given the path to a flatfile for the gene_input argument, or have provided the name of a dataframe object for the gene_df argument.')
stop()
}
###############
gene_table <- gene_table %>%
dplyr::rename_with(~ taxonomic_lvls[stringr::str_detect(taxonomic_lvls, stringr::regex(., ignore_case = TRUE))], .cols = dplyr::contains(taxonomic_lvls)) %>%
{if (cat == TRUE) tidy_cat_taxa(., taxonomic_lvls = taxonomic_lvls, tax_cols = tax_cols)
else if (!is.null(custom_anno_ColNames)) tidy_custom_taxa(., cutoff = cutoff)
else stop(cli::cli_alert_danger('Error: Input format does not match any of the accepted formats. Please see usage()'))}
# read in gene flatfile, or optionally a dataframe containing the gene information
if (all(!is.null(ko_input) & ko_df == FALSE)) {
cli::cli_h1('Reading KEGG Orthology data into MetaPredict')
ko_table <- suppressWarnings(readr::read_delim(ko_input, col_types = readr::cols(),
delim = ko_delim))
} else if (all(!is.null(ko_input) & is.data.frame(ko_df))) {
cli::cli_alert_danger('Error: Either a KEGG Orthology input flatfile or a KEGG Orthology dataframe is required. Both types of inputs were detected. Make sure to use either one or the other input type, not both.')
stop()
} else if (all(is.null(ko_input) & is.data.frame(ko_df))) {
ko_table <- ko_df
} else {
cli::cli_alert_danger('Error: Kegg Orthology input flatfile/gene dataframe not detected. Make sure you have given the path to a flatfile for the ko_input argument, or have provided the name of a dataframe object for the ko_df argument.')
stop()
}
###############
ko_table <- ko_table %>%
{if (kofamscan == TRUE) tidy_kofam.mg(., cutoff = cutoff)
else if (!is.null(custom_knumber_ColNames)) tidy_custom_anno(., cutoff = cutoff, input_type = 'metagenome_name')
else stop(cli::cli_alert_danger('Error message')) }
if (!('metagenome_name' %in% colnames(metadata_tbl)) & !('metagenome_name' %in% colnames(ko_table))) {
if (!is.null(ko_input)) {
default_name <- sub('.*\\/(.*)\\..*', '\\1', ko_input, perl = T)
} else if (is.data.frame(ko_df)) {
default_name <- deparse(substitute(ko_df))
} else {
stop(cli::cli_alert_danger('Error: Could not create default name for metagenome. Make sure input data and arguments were formatted properly.'))
}
cli::cli_alert_info('Metagenome name(s) not provided/detected. Using default metagenome name: {default_name}')
} else {default_name <- NULL}
#need this somewhere .... #dplyr::filter(!(duplicated(k_number)))
gene_table <- gene_table %>%
merge_tables(ko_table, metadata_tbl, default_name = default_name)
cli::cli_alert_success('Parsed predicted genes and gene taxonomic annotations')
cli::cli_alert_success('Parsed HMM/Blast hits and E-values')
cli::cli_alert_info('Used E-value cutoff: {cutoff}')
return(gene_table)
}
tidy_kofam.mg <- function(.data, cutoff = 1e-3) {
.data %>%
dplyr::filter(!stringr::str_detect(`E-value`, '-----')) %>%
{if (all(c('E-value', 'KO', 'gene name') %in% colnames(.))) dplyr::select(., `E-value`, KO, `gene name`)
else stop(cli::cli_alert_danger(
"Error: Columns 'E-value', 'KO', and 'gene name' not detected. These columns are required to read in Kofamscan output files."))} %>%
dplyr::mutate(`E-value` = as.numeric(`E-value`)) %>%
dplyr::filter(`E-value` <= cutoff | `E-value` == 0) %>%
dplyr::select(KO, `gene name`) %>%
dplyr::rename(gene_name = `gene name`, k_number = KO) %>%
dplyr::filter(!is.na(k_number))
}
tidy_cat_taxa <- function(.data, taxonomic_lvls, tax_cols) {
.data %>%
dplyr::rename_at(dplyr::vars(dplyr::contains('Superkingdom')), ~ paste0('Domain')) %>%
dplyr::rename_at(dplyr::vars(dplyr::contains('ORF')), ~ paste0('ORF')) %>%
tibble::add_column(!!!tax_cols[!names(tax_cols) %in% names(.)]) %>%
dplyr::mutate(Domain = dplyr::case_when(Domain == 'not classified' ~ NA_character_,
lineage == 'no taxid found' ~ NA_character_,
lineage == 'no hit to database' ~ NA_character_,
TRUE ~ Domain)) %>%
dplyr::mutate(dplyr::across(dplyr::all_of(taxonomic_lvls), ~ sub('not classified', NA, .x)),
dplyr::across(dplyr::all_of(taxonomic_lvls), ~ sub('.*\\*$', NA, .x)),
taxonomy = dplyr::coalesce(Genus, Family, Order, Class, Phylum, Domain)) %>% #, #coalesce takes the lowest tax level as input
#taxonomy = stringr::str_replace_all(taxonomy,
#                                    stringr::regex(c('Candidatus ' = '', '\\*+' = '',
#                                                     'candidate division ' = ''),
#                                                   ignore_case = TRUE))) %>%
dplyr::rename(gene_name = ORF) %>%
dplyr::select(gene_name, taxonomy) %>%
dplyr::filter(taxonomy != 'Viruses')
}
#fn to join gene annotation, contig/scaffold taxonomic annotation, and metagenome completeness tibbles
merge_tables <- function(.data, ko_table, metadata_tbl, default_name = NULL) {
.data %>%
dplyr::full_join(ko_table, by = 'gene_name') %>%
dplyr::filter(!(is.na(k_number))) %>%
dplyr::mutate(taxonomy = dplyr::case_when(
is.na(taxonomy) ~ 'unidentified taxonomy',
TRUE ~ taxonomy)) %>%
dplyr::arrange(taxonomy) %>%
dplyr::group_by(taxonomy) %>%
dplyr::summarize(k_number = paste0(k_number, collapse = ' '),
gene_name = paste0(gene_name, collapse = ' '),
taxonomy = unique(taxonomy),
.groups = 'keep') %>%
{if (!is.null(default_name)) dplyr::mutate(., metagenome_name = default_name)
else (.)} %>%
dplyr::mutate(data_type = 'metagenome',# requires if/else statement - names might be provided by user
completeness = metadata_tbl$completeness[1])
}
tidy_custom_taxa <- function(.data, cutoff = 1e-3) {
taxonomic_lvls <- c('Genus', 'Family', 'Order', 'Class', 'Phylum', 'Domain')
tax_cols <- c('Genus' = NA, 'Family' = NA, 'Order' = NA, 'Class' = NA, 'Phylum' = NA, 'Domain' = NA)
.data %>%
{if ('gene_name' %in% colnames(.) & any(taxonomic_lvls %in% colnames(.))) dplyr::select(., gene_name, dplyr::contains(taxonomic_lvls))
else stop(cli::cli_alert_danger(
"Error: Custom taxonomy file must contain column 'gene_name' and at least one column with a taxonomic level (Genus, Family, Order, Class, and/or Phylum).
The lowest taxonomic level down to Genus will be used. Please see usage() for more information"))} %>%
purrr::modify(taxonomic_lvls, function(.col) {dplyr::rename(., dplyr::across(dplyr::contains(.col), ~ .col))}) %>%
tibble::add_column(!!!tax_cols[!names(tax_cols) %in% names(.)]) %>%
dplyr::mutate(dplyr::across(dplyr::all_of(taxonomic_lvls), ~ sub('not classified', NA, .x)),
taxonomy = dplyr::coalesce(Genus, Family, Order, Class, Phylum, Domain)) %>% #, #coalesce takes the lowest tax level as input
#taxonomy = stringr::str_replace_all(taxonomy,
#                                    stringr::regex(c('Candidatus ' = '', '\\*+' = '',
#                                                     'candidate division ' = ''),
#                                                   ignore_case = TRUE))) %>%
dplyr::select(gene, taxonomy)
}
test.filt
test.filt <- rename(completeness = p_j)
test.filt %>% rename(completeness = p_j)
test.filt <- test.filt %>% rename(completeness = p_j)
x_j.list
results <- map_modules_to(x_j.list, test.filt)# this function should be split into 2 parts
results2 <- get_parameters(results)
results3 <- get_posteriors(results)
results3 <- get_posteriors(results2)
View(results3)
View(results3[[25]])
res.mg = MetaPredict::MetaPredict(test.filt, strict = TRUE)
View(res.mg)
View(res.mg[["ko"]][[1]])
View(res.mg[["ko"]][[2]])
ko
#next - dealing with multiple KO hits to the same gene...
ko %>%
group_by(`gene name`) %>%
filter(score = max(score))
#next - dealing with multiple KO hits to the same gene...
ko %>%
group_by(`gene name`) %>%
filter(score == max(score))
#next - dealing with multiple KO hits to the same gene...
ko_filt.byScore <- ko %>%
group_by(`gene name`) %>%
filter(score == max(score)) %>%
ungroup()
View(ko_filt.byScore)
table(duplicated(ko_filt.byScore$`gene name`))
table(is.na(ko_filt.byScore$score))
ko_split <- ko_filt.byScore %>%
group_by(`gene name`) %>%
group_split()
View(ko_split)
ko_split %>%
keep(~ length(.x) > 1)
ko_split %>%
keep(~ length(.x$`gene name`) > 1)
#next - dealing with multiple KO hits to the same gene...
ko_filt.byScore <- ko %>%
filter(`E-value` <= 1e-3 | `E-value` == 0) %>%
group_by(`gene name`) %>%
filter(score == max(score) & `E-value` == min(`E-value`)) %>%
ungroup()
table(duplicated(ko_filt.byScore$`gene name`))
rm(ko_split)
ko_filt.byScore %>%
group_by(`gene name`) %>%
filter(length(`gene name`) > 1) %>% View()
ko_filt.byScore %>%
group_by(`gene name`) %>%
filter(length(`gene name`) > 1) %>% summarize(length = sum(`gene name`)) %>% View()
ko_filt.byScore %>%
group_by(`gene name`) %>%
filter(length(`gene name`) > 1) %>% summarize(length = length(`gene name`)) %>% View()
ko_filt.byScore
res.mg2 = MetaPredict::MetaPredict(ko_filt.byScore, strict = TRUE)
ko_filt.byScore
meta_df <- tibble('metagenome_name' = 'test_mg', completeness = 92)
meta_df
res.mg2 = read_metagenome_data(gene_df = genes, ko_df = ko_filt.byScore, metadata_df = meta_df)
res.mg2
res.mg2 %>% filter((str_count(k_number, pattern = ' ') + 1) >= 50)
res.mg2 %>% filter((str_count(k_number, pattern = ' ') + 1) >= 25)
res.mg2 %>% filter((str_count(k_number, pattern = ' ') + 1) >= 100)
devtools::document()
